# Docker in docker (dind) image

This repository provides an docker in docker image that is used in the PADME ecosystem. See [the documentation](https://docs.padme-analytics.de/) for more information on the different PADME services and the service architecture. An overview of all open source services is available [here](https://git.rwth-aachen.de/padme-development).

Visit our website at [padme-analytics.de](https://padme-analytics.de).

## Changes over the original dind image

This image contains some additions/configurations that are added on top of the existing/official dind image. The reason for this change is that with the default dind image, containers running inside dind cannot properly do name (DNS) resolution in some host machine configurations. The reason for this behavior is explained in the following.

When docker creates a container, it copies the entries in the /etc/resolv.conf file of the host to the container. This file usually configures which DNS server a system uses. Consequently, the container uses the same DNS configuration as the host. However, in this process of copying entires, local host entries in resolv.conf are ignored by docker because those entries will not be reachable from within the container (in the container, 'localhost' resolves to the container itself, not its host).

This is not a problem until one considers a popular dns configuration on many linux based machines: Many linux machines are configured to have a locally running dns server for caching (like dnsmasq) that then uses its own DNS configuration for resolution. This means, this DNS server is configured with a localhost address in the /etc/resolve.conf file. Consequently, this server will not get copied to the container on creation. This will leave the container without any DNS configuration. In this case, docker uses the Google DNS servers (8.8.8.8 and 8.8.4.4) as a fallback. However, those servers are often blocked in internal networks due to organizations having their own dns servers that should be used instead. Overall, this leads to the container not being able to do any name resolution.

Now there is one more layer to this problem that arises when one uses docker defined virtual networks. Containers that are part of a virtual network do not get the copied entries from /etc/resolv.conf directly. Instead, docker manages its own DNS server (usually reachable from within the container at 127.0.0.11:53). This server takes the entries from /etc/resolv.conf of the host into account and additionally resolves hostnames of other docker containers (e.g. with this setup a app server can resolve the 'postgres' hostname used for the corresponding DB server).

In our configuration, dind will always be running as part of a virtual network. This means that the dind container will have 127.0.0.11 as its DNS server. Due to the docker engine managing this server, DNS resolution within dind will work fine since the engine can pass trough requests to the DNS server of the host (the engine runs on the host and can therefore use the hosts localhost dns server). Now we get to the problem that our additions solve: When we start containers within dind, that are not part of a virtual network (as is the default for our software), those containers will get a copy of the resolve.conf of the dind container. This resolv.conf only contains the 127.0.0.11 entry of the docker managed DNS server. Consequently, docker does not copy this entry and uses the Google DNS as a fall back. If those DNS servers are now blocked in the network, containers running inside the dind do not have working name resolution. 

Our solution to this problem is to have a DNS server (dnsmasq) running within the dind container. This server is binded to 172.31.0.1, which we configured as the gateway IP address in the default bridge network (the IP address that the docker engine has in this network). Given that the containers running within dind are attached to this network by default (unless a user specified network is used, in which case the problem does not exist), this IP is reachable from all those containers. Moreover, we added the ip of this dns server to the resolv.conf file of the dind. Since the IP of the new DNS server is not a localhost one, this IP will be copied as a DNS resolution target to all containers running within dind. This means, docker does not fall back to the google DNS servers and the DNS resolution from within the containers in dind works!

Now one last question might remain: How does our new dns server actually do the resolution? Well, the resolv.conf file within the dind also has the entry of the docker managed DNS server. Our DNS server uses this config to find other servers that can be used for resolution. Therefore, the requests from the containers running within dind are send to our DNS server, which passes it trough to the docker managed DNS server (which uses the host configured one).